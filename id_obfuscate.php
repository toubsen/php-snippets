<?php

/**
 * Class to obfuscate database IDs and prepend them with a cryptographic
 * HMAC to ensure that an obfuscated ID has been generated by the 
 * issuer. This allows for e.g. giving out links to a user, that shall
 * be granted access to a single resource without further authentication
 * checks, without the possibility to test for or access other
 * resources.
 * 
 * The HMAC can be truncated to generate shorter obfuscated IDs, e.g. to
 * allow for easier manual type in by a user (e.g. printed codes). The
 * truncation will affect the security of this construct, so depending
 * on your use case, you take choose the full HMAC size for security.
 * 
 * Additions:
 * This will just project you from people trying to probe for ids to
 * access resources without other forms of access control. It will not
 * help against replay attacks. Also the id is just encoded to another
 * format, not encrypted, so consider it still as "visible" to any user.
 * This has the implication, to use different keys for each type of
 * resource to protect, else valid tokens from one resource can be 
 * reused on other resources where an item with the same id exists.
 * 
 * @author Tobias Vogel  <tobi089@web.de>
 */
class IdObfuscator {

    /**
	 * @var string Hashing algoorithm to use
	 */
	private $hashFn = 'sha256';
	
	/**
	 * @var integer Length of truncated HMAC in bits 
	 */
	private $hmacLen = 64;
	
	/**
	 * The key to use for HMAC creation and verification
	 */
	private $key = null;
	
	/**
	 * Creates a new ID obfuscator.
	 * 
	 * @param string $password A password to generate a key from
     * @param string $salt The salt to use for key creation
	 * @param integer $hmacLen Length of the HMAC, defaults to 64 bits
	 */
	public function __construct($password, $salt, $hmacLen = 64) {
		$this->key = $this->genKey($password, $salt);
        $this->hmacLen = $hmacLen;
	}
    
    /**
     * Abbreviated PBKDF2 function to create a HMAC key.
     * 
     * @link https://defuse.ca/php-pbkdf2.htm
     */
    private function genKey($password, $salt) {
        $algorithm = 'sha256';
        $count = 1000;
        
        $last = $salt . pack("N", $i);
        $last = $xorsum = hash_hmac($algorithm, $last, $password, true);
        for ($j = 1; $j < $count; $j++) {
            $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, true));
        }
        
        return $xorsum;
    }

	/**
	 * Base convert alternative for big integers, that works with
	 * integers of any size and up to base 62.
	 * 
	 * Assembled from the information in the following thread:
	 * @link http://stackoverflow.com/questions/1938029/php-how-to-base-convert-up-to-base-62
	 * 
	 * @param string $numstring number to convert
	 * @param integer $frombase The base the number is encoded in
	 * @param integer $tobase The base the number willbe converted to
	 * @return string The converted number
	 */
	public function bcBaseConvert($numstring, $frombase, $tobase) {
		$alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

		$chars = substr($alphabet, 0, $frombase);
		$tostring = substr($alphabet, 0, $tobase);

        $numstring = (string) $numstring;
		$length = strlen($numstring);
		$result = '';
		for ($i = 0; $i < $length; $i++) {
			$number[$i] = strpos($chars, $numstring{$i});
		}
		do {
			$divide = 0;
			$newlen = 0;
			for ($i = 0; $i < $length; $i++) {
				$divide = $divide * $frombase + $number[$i];
				if ($divide >= $tobase) {
					$number[$newlen++] = (int)($divide / $tobase);
					$divide = $divide % $tobase;
				} elseif ($newlen > 0) {
					$number[$newlen++] = 0;
				}
			}
			$length = $newlen;
			$result = $tostring{$divide} . $result;
		}
		while ($newlen != 0);
		return $result;
	}

	/**
	 * Encodes / Obfuscates an ID in base36 encoding and prepends it
	 * with a message HMAC of the defined size.
	 * 
	 * @param integer $id The id to encode
	 * @return string base36 encoded HMAC + id
	 */
	public function encode($id) {
		$idEnc = $this->bcBaseConvert($id, 10, 36);
		$hmac = $this->getHmac($id);
		$hmacEnc = $this->bcBaseConvert($hmac, 16, 36);
		return str_pad($hmacEnc, 13, '0', STR_PAD_LEFT) .$idEnc;
	}

	/**
	 * Decodes / De-Obfuscates an ID in base36 encoding and verifies the
	 * integrity with the given HMAC.
	 * 
	 * @param string $code The code to encode
	 * @return id The given id if valid, else 0
	 */
	public function decode($code) {
		$idEnc = substr($code, 13);
		$id = $this->bcBaseConvert($idEnc, 36, 10);

		$hmacEnc = substr($code, 0, 13);
		$hmacUser = $this->bcBaseConvert($hmacEnc, 36, 16);
		$hmac = $this->getHmac($id);	

		// Compare MD5 hashes to prevent timing attacks
		if (md5($hmac) !== md5($hmacUser)) {
			echo "tampered data detected!\n";
			return 0;
		}

		return $id;
	}

	/**
	 * Creates a HMAC for a message m with key k, truncated to the
	 * number of bits defined in HMAC_LEN. The result is a string with
	 * lowercase hexits.
	 * 
	 * @param string $message The message to create a HMAC for
	 * @return string The (possibly truncated) message HMAC
	 */
	private function getHmac($message) {
		$hmac = hash_hmac('sha256', $message, $this->key);
		return substr($hmac, 0, $this->hmacLen / 4);
	}

}

$idObf = new IdObfuscator('mypass', 'mysalt');

echo '<pre>';
echo "encoded: " . $idObf->encode(PHP_INT_MAX) . "\n";
echo " deoded: " . $idObf->decode('0ysefwkeu0qzk1') . "\n";

